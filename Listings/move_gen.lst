C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MOVE_GEN
OBJECT MODULE PLACED IN .\Objects\move_gen.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\move_gen.c OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\move_gen.lst) TABS(2) OBJECT(.\Objects\move_gen.obj)

line level    source

   1          #include "move_gen.h"
   2          
   3          #include "types.h"
   4          #include "bitboard.h"
   5          #include "interrupts.h"
   6          #include "types.h"
   7          
   8          // King directions
   9          static const signed char code dr[8] = {-1,-1,-1,0,0,1,1,1};
  10          static const signed char code df[8] = {-1,0,1,-1,1,-1,0,1};
  11          
  12          // Rook directions
  13          static const signed char code dr_rook[4] = { -1,  1,  0,  0 };
  14          static const signed char code df_rook[4] = {  0,  0, -1,  1 };
  15          
  16          // Bishop directions
  17          static const signed char code dr_bishop[4] = { -1, -1,  1,  1 };
  18          static const signed char code df_bishop[4] = { -1,  1, -1,  1 };
  19          
  20          // Knight directions
  21          static const signed char code dr_knight[8] = { -2, -2, -1, -1,  1,  1,  2,  2 };
  22          static const signed char code df_knight[8] = { -1,  1, -2,  2, -2,  2, -1,  1 };
  23          
  24          #define WHITE_PAWN_START_RANK 1
  25          #define BLACK_PAWN_START_RANK 6
  26          
  27          
  28          U8 GAME_OVER_INFO = 0;
  29          
  30          
  31          void apply_move(U8 FromSquare, U8 ToSquare, bit emit) {
  32   1        U8 FromRank, FromFile;
  33   1        U8 ToRank, ToFile;
  34   1        
  35   1        bit whichCastlingSide, isCastling;
  36   1        whichCastlingSide = 0;
  37   1        isCastling = 0;
  38   1        
  39   1      
  40   1        FromRank = FromSquare >> SHIFT;
  41   1        FromFile = FromSquare & MASK;
  42   1        
  43   1        ToRank = ToSquare >> SHIFT;
  44   1        ToFile = ToSquare & MASK;
  45   1        
  46   1        if ((BoardState[(FromRank << SHIFT) | FromFile] & TYPE_MASK) == TYPE_KING) {
  47   2          // Check if the move is short castle
  48   2          if (!KingMoved[TURN] && ((FromFile==4 && ToFile==6) || (FromFile==4 && ToFile==2))) {
  49   3            isCastling = 1;
  50   3            if (ToFile == 6) {
  51   4              whichCastlingSide = 0; // SHORT
  52   4            } else if (ToFile == 2) { 
  53   4              whichCastlingSide = 1; // LONG
  54   4            }
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 2   

  55   3            
  56   3            MoveSquares[0] = FromRank;
  57   3            MoveSquares[1] = whichCastlingSide == 0 ? 7 : 0;
  58   3            MoveSquares[2] = ToRank;
  59   3            MoveSquares[3] = whichCastlingSide == 0 ? 5 : 3;
  60   3            
  61   3            DisplayBoardLEDs.RANK[0] = 0;
  62   3            DisplayBoardLEDs.RANK[1] = 0;
  63   3            DisplayBoardLEDs.RANK[2] = 0;
  64   3            DisplayBoardLEDs.RANK[3] = 0;
  65   3            DisplayBoardLEDs.RANK[4] = 0;
  66   3            DisplayBoardLEDs.RANK[5] = 0;
  67   3            DisplayBoardLEDs.RANK[6] = 0;
  68   3            DisplayBoardLEDs.RANK[7] = 0;
  69   3            
  70   3            DisplayBoardLEDs.RANK[MoveSquares[0]] |= 1 << MoveSquares[1];
  71   3            DisplayBoardLEDs.RANK[MoveSquares[2]] |= 1 << MoveSquares[3];
  72   3          
  73   3            
  74   3            MOVE_RECEIVED = 1;
  75   3          }
  76   2            
  77   2          KingSquares[TURN] = (ToRank << SHIFT) | ToFile;
  78   2          KingMoved[TURN] = 1;
  79   2        }
  80   1        
  81   1        if ((BoardState[(FromRank << SHIFT) | FromFile] & TYPE_MASK) == TYPE_ROOK) {
  82   2          RookMoved[TURN][FromFile > 4 ? LONG_ROOK : SHORT_ROOK] = 1;
  83   2        }
  84   1        
  85   1        BoardState[(ToRank << SHIFT) | ToFile] = BoardState[(FromRank << SHIFT) | FromFile];
  86   1        BoardState[(FromRank << SHIFT) | FromFile] = EMPTY;
  87   1        
  88   1        CurrentBoard.RANK[FromRank] &= ~(1 << FromFile);
  89   1        CurrentBoard.RANK[ToRank] |= 1 << ToFile;
  90   1        
  91   1        // Toggle turn
  92   1        if (!isCastling) TURN = !TURN;
  93   1        if (isCastling) {
  94   2            MoveBoard = CurrentBoard;
  95   2          
  96   2            MoveBoard.RANK[MoveSquares[0]] &= ~(1 << MoveSquares[1]);
  97   2            MoveBoard.RANK[MoveSquares[2]] |= 1 << MoveSquares[3];
  98   2        }
  99   1        
 100   1        if (!emit) return;
 101   1        
 102   1        txHeader = HEADER;
 103   1        txType = MOVE_PACKET;
 104   1        txLen = 0x02;
 105   1        
 106   1        txBuffer[0] = LiftedPieceSquare;
 107   1        txBuffer[1] = ToSquare;
 108   1        
 109   1        txPacketReady = 1;
 110   1      }
 111          
 112              
 113          void get_legal_moves(U8 sq, Bitboard *legal_board, bit pass) {
 114   1      
 115   1          U8 r, f, to_sq;
 116   1          bit piece_turn;
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 3   

 117   1          U8 from_piece, captured_piece;
 118   1          U8 old_king_sq;
 119   1      
 120   1          Bitboard pseudo_board;
 121   1      
 122   1          pseudo_board.RANK[0] = 0;
 123   1          pseudo_board.RANK[1] = 0;
 124   1          pseudo_board.RANK[2] = 0;
 125   1          pseudo_board.RANK[3] = 0;
 126   1          pseudo_board.RANK[4] = 0;
 127   1          pseudo_board.RANK[5] = 0;
 128   1          pseudo_board.RANK[6] = 0;
 129   1          pseudo_board.RANK[7] = 0;
 130   1      
 131   1          *legal_board  = ZeroBoard;
 132   1      
 133   1          from_piece = BoardState[sq];
 134   1          old_king_sq = KingSquares[TURN];
 135   1        
 136   1          if ((from_piece & TYPE_MASK) == TYPE_EMPTY) return;
 137   1      
 138   1          piece_turn = (from_piece & COLOR_WHITE) != 0;
 139   1      
 140   1          if (piece_turn != TURN) return;
 141   1          if (!pass) if (piece_turn != COLOR) return;
 142   1      
 143   1          /* --- Generate pseudo-legal moves --- */
 144   1          switch (from_piece & TYPE_MASK) {
 145   2              case TYPE_PAWN:
 146   2                  get_pawn_moves(sq, &pseudo_board);
 147   2                  break;
 148   2              case TYPE_KNIGHT:
 149   2                  get_knight_moves(sq, &pseudo_board);
 150   2                  break;
 151   2              case TYPE_BISHOP:
 152   2                  get_bishop_moves(sq, &pseudo_board);
 153   2                  break;
 154   2              case TYPE_ROOK:
 155   2                  get_rook_moves(sq, &pseudo_board);
 156   2                  break;
 157   2              case TYPE_QUEEN:
 158   2                  get_bishop_moves(sq, &pseudo_board);
 159   2                  get_rook_moves(sq, &pseudo_board);
 160   2                  break;
 161   2              case TYPE_KING:
 162   2                  get_king_moves(sq, &pseudo_board);
 163   2                  break;
 164   2              default:
 165   2                  break;
 166   2          }
 167   1      
 168   1          /* --- Filter to legal moves --- */
 169   1          for (r = 0; r < BOARD_W; r++) {
 170   2              for (f = 0; f < BOARD_W; f++) {
 171   3      
 172   3                  if (!(pseudo_board.RANK[r] & (1 << f))) continue;
 173   3      
 174   3                  to_sq = (r << SHIFT) | f;
 175   3      
 176   3                  /* make temporary move */
 177   3                  captured_piece = BoardState[to_sq];
 178   3                  BoardState[to_sq] = from_piece;
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 4   

 179   3                  BoardState[sq] = TYPE_EMPTY;
 180   3      
 181   3                  if ((from_piece & TYPE_MASK) == TYPE_KING)
 182   3                      KingSquares[TURN] = to_sq;
 183   3      
 184   3                  /* check king safety */
 185   3                  if (!is_square_attacked(KingSquares[TURN], !TURN)) {
 186   4                      legal_board->RANK[r] |= (1 << f);
 187   4                  }
 188   3      
 189   3                  /* undo move */
 190   3                  BoardState[sq] = from_piece;
 191   3                  BoardState[to_sq] = captured_piece;
 192   3                  KingSquares[TURN] = old_king_sq;
 193   3              }
 194   2          }
 195   1      
 196   1      }
 197          
 198          
 199          void get_pawn_moves(U8 sq, Bitboard *board) { 
 200   1          U8 color, rank, file, new_sq, new_rank, target, start_rank;
 201   1          signed char dir, step;
 202   1          
 203   1          rank = sq >> SHIFT;
 204   1          file = sq & MASK;
 205   1        
 206   1          color = BoardState[sq] & COLOR_WHITE;
 207   1        
 208   1          if (color & COLOR_WHITE) {
 209   2            dir = 1;
 210   2            start_rank = WHITE_PAWN_START_RANK;
 211   2          } else {
 212   2            dir = -1;
 213   2            start_rank = BLACK_PAWN_START_RANK;
 214   2          }
 215   1         
 216   1          step = dir << SHIFT;
 217   1          new_rank = rank + dir;
 218   1          
 219   1          if (new_rank < BOARD_W && new_rank >=0) {
 220   2            new_sq = sq + step;
 221   2            
 222   2            if ((BoardState[new_sq] & TYPE_MASK) == TYPE_EMPTY) { // VALID SINGLE PUSH
 223   3              board->RANK[new_rank] |= (1 << file);
 224   3              new_sq += step; 
 225   3              
 226   3              if (rank == start_rank && (BoardState[new_sq] & TYPE_MASK) == TYPE_EMPTY) board->RANK[new_rank + dir] 
             -|= (1 << file); // DOUBLE PUSH
 227   3            }
 228   2          }
 229   1           
 230   1        // CAPTURES
 231   1        if (file > 0 && new_rank >= 0 && new_rank < BOARD_W) {
 232   2          new_sq = sq + step - 1; // LEFT CAPTURE - WHTIE
 233   2          target = BoardState[new_sq];
 234   2          if ((target & TYPE_MASK) != TYPE_EMPTY && (target & COLOR_WHITE) != color) board->RANK[new_rank] |= (1 <
             -< (file-1)); 
 235   2        }
 236   1          
 237   1        if (file < BOARD_W - 1 && new_rank >= 0 && new_rank < BOARD_W) {
 238   2          new_sq = sq + step + 1; // RIGHT CAPTURE - WHTIE
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 5   

 239   2          target = BoardState[new_sq];
 240   2          if ((target & TYPE_MASK) != TYPE_EMPTY && (target & COLOR_WHITE) != color) board->RANK[new_rank] |= (1 <
             -< (file+1)); 
 241   2        }
 242   1        
 243   1      }
 244          
 245          void get_king_moves(U8 sq, Bitboard *board) {
 246   1        U8 i, piece, color, rank, file, new_sq, target, side;
 247   1        signed char r, f;
 248   1        
 249   1          piece = BoardState[sq];
 250   1          color = piece & COLOR_WHITE;
 251   1          rank = sq >> SHIFT;
 252   1          file = sq & MASK;
 253   1        
 254   1          side = (color != 0);
 255   1      
 256   1          // King direction offsets
 257   1      
 258   1      
 259   1          for (i=0; i<8; i++) {
 260   2              r = rank + dr[i];
 261   2              f = file + df[i];
 262   2      
 263   2              if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 264   2                  continue;
 265   2      
 266   2              new_sq = (r << SHIFT) + f;
 267   2              target = BoardState[new_sq];
 268   2      
 269   2              if ((target & TYPE_MASK) == TYPE_EMPTY || (target & COLOR_WHITE) != color) {
 270   3                  board->RANK[r] |= (1 << f);
 271   3              }
 272   2          }
 273   1          
 274   1          if (KingMoved[side]) return;
 275   1          
 276   1          // Short castling check
 277   1          if (!RookMoved[side][SHORT_ROOK]) {
 278   2            if (((BoardState[(rank << SHIFT) | (file+1)] & TYPE_MASK) == TYPE_EMPTY) && ((BoardState[(rank << SHIFT
             -) | (file+2)] & TYPE_MASK) == TYPE_EMPTY)) {
 279   3              board->RANK[rank] |= (1 << (file+2));
 280   3            }
 281   2          }
 282   1          
 283   1          // Long castling check
 284   1          if (!RookMoved[side][LONG_ROOK]) {
 285   2            if (((BoardState[(rank << SHIFT) | (file-1)] & TYPE_MASK) == TYPE_EMPTY) && ((BoardState[(rank << SHIFT
             -) | (file-2)] & TYPE_MASK) == TYPE_EMPTY) && ((BoardState[(rank << SHIFT) | (file-3)] & TYPE_MASK) == TYPE_EMPTY)) {
 286   3              board->RANK[rank] |= (1 << (file-2));
 287   3            }
 288   2          }
 289   1      }
 290          
 291          void get_rook_moves(U8 sq, Bitboard *board) {
 292   1          U8 i, piece, color, target;
 293   1          signed char r, f;
 294   1          U8 rank, file;
 295   1      
 296   1          piece = BoardState[sq];
 297   1          color = piece & COLOR_WHITE;
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 6   

 298   1          rank = sq >> SHIFT;
 299   1          file = sq & MASK;
 300   1      
 301   1          for (i = 0; i < 4; i++) {
 302   2              r = rank;
 303   2              f = file;
 304   2      
 305   2              while (1) {
 306   3                  r += dr_rook[i];
 307   3                  f += df_rook[i];
 308   3      
 309   3                  if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 310   3                      break;
 311   3      
 312   3                  target = BoardState[(r << SHIFT) + f];
 313   3      
 314   3                  if ((target & TYPE_MASK) == TYPE_EMPTY) {
 315   4                      board->RANK[r] |= (1 << f);
 316   4                  } else {
 317   4                      if ((target & COLOR_WHITE) != color)
 318   4                          board->RANK[r] |= (1 << f);
 319   4                      break;   // blocked
 320   4                  }
 321   3              }
 322   2          }
 323   1      }
 324          
 325          void get_bishop_moves(U8 sq, Bitboard *board) {
 326   1          U8 i, piece, color, target;
 327   1          signed char r, f;
 328   1          U8 rank, file;
 329   1      
 330   1          piece = BoardState[sq];
 331   1          color = piece & COLOR_WHITE;
 332   1          rank = sq >> SHIFT;
 333   1          file = sq & MASK;
 334   1      
 335   1          for (i = 0; i < 4; i++) {
 336   2              r = rank;
 337   2              f = file;
 338   2      
 339   2              while (1) {
 340   3                  r += dr_bishop[i];
 341   3                  f += df_bishop[i];
 342   3      
 343   3                  if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 344   3                      break;
 345   3      
 346   3                  target = BoardState[(r << SHIFT) + f];
 347   3      
 348   3                  if ((target & TYPE_MASK) == TYPE_EMPTY) {
 349   4                      board->RANK[r] |= (1 << f);
 350   4                  } else {
 351   4                      if ((target & COLOR_WHITE) != color)
 352   4                          board->RANK[r] |= (1 << f);
 353   4                      break;   // blocked
 354   4                  }
 355   3              }
 356   2          }
 357   1      }
 358          
 359          void get_knight_moves(U8 sq, Bitboard *board) {
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 7   

 360   1          U8 i, piece, color, target;
 361   1          signed char r, f;
 362   1          U8 rank, file;
 363   1      
 364   1          piece = BoardState[sq];
 365   1          color = piece & COLOR_WHITE;
 366   1          rank = sq >> SHIFT;
 367   1          file = sq & MASK;
 368   1      
 369   1          for (i = 0; i < 8; i++) {
 370   2              r = rank + dr_knight[i];
 371   2              f = file + df_knight[i];
 372   2      
 373   2              if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 374   2                  continue;
 375   2      
 376   2              target = BoardState[(r << SHIFT) + f];
 377   2      
 378   2              if ((target & TYPE_MASK) == TYPE_EMPTY || (target & COLOR_WHITE) != color) {
 379   3                  board->RANK[r] |= (1 << f);
 380   3              }
 381   2          }
 382   1      }
 383          
 384          bit is_square_attacked(U8 sq, bit attacker_color) {
 385   1          U8 r = sq >> SHIFT;
 386   1          U8 f = sq & MASK;
 387   1          signed char nr, nf, pr;
 388   1          U8 i, nsq, piece, type;
 389   1        
 390   1          /* ---------- Pawn attacks ------------ */
 391   1          pr = attacker_color ? -1 : 1;
 392   1      
 393   1          if (r + pr >= 0 && r + pr < BOARD_W) {
 394   2              if (f > 0) {
 395   3                  piece = BoardState[((r + pr) << SHIFT) | (f - 1)];
 396   3                  if ((piece & TYPE_MASK) == TYPE_PAWN &&
 397   3                      ((piece & COLOR_WHITE) != 0) == attacker_color)
 398   3                      return 1;
 399   3              }
 400   2              if (f < BOARD_W - 1) {
 401   3                  piece = BoardState[((r + pr) << SHIFT) | (f + 1)];
 402   3                  if ((piece & TYPE_MASK) == TYPE_PAWN &&
 403   3                      ((piece & COLOR_WHITE) != 0) == attacker_color)
 404   3                      return 1;
 405   3              }
 406   2          }
 407   1      
 408   1      
 409   1          /* ---------- Knight attacks ---------- */
 410   1          for (i = 0; i < 8; i++) {
 411   2              nr = r + dr_knight[i];
 412   2              nf = f + df_knight[i];
 413   2      
 414   2              if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 415   2                  continue;
 416   2      
 417   2              nsq = (nr << SHIFT) | nf;
 418   2              piece = BoardState[nsq];
 419   2      
 420   2              if ((piece & TYPE_MASK) == TYPE_KNIGHT && ((piece & COLOR_WHITE) != 0) == attacker_color) return 1
             -;
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 8   

 421   2          }
 422   1      
 423   1          /* ---------- Rook / Queen attacks ---------- */
 424   1          for (i = 0; i < 4; i++) {
 425   2              nr = r;
 426   2              nf = f;
 427   2      
 428   2              while (1) {
 429   3                  nr += dr_rook[i];
 430   3                  nf += df_rook[i];
 431   3      
 432   3                  if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 433   3                      break;
 434   3      
 435   3                  nsq = (nr << SHIFT) | nf;
 436   3                  piece = BoardState[nsq];
 437   3      
 438   3                  if ((piece & TYPE_MASK) == TYPE_EMPTY)
 439   3                      continue;
 440   3      
 441   3                  if (((piece & COLOR_WHITE) != 0) == attacker_color) {
 442   4                      type = piece & TYPE_MASK;
 443   4                      if (type == TYPE_ROOK || type == TYPE_QUEEN)
 444   4                          return 1;
 445   4                  }
 446   3                  break;  // blocked
 447   3              }
 448   2          }
 449   1      
 450   1          /* ---------- Bishop / Queen attacks ---------- */
 451   1          for (i = 0; i < 4; i++) {
 452   2              nr = r;
 453   2              nf = f;
 454   2      
 455   2              while (1) {
 456   3                  nr += dr_bishop[i];
 457   3                  nf += df_bishop[i];
 458   3      
 459   3                  if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 460   3                      break;
 461   3      
 462   3                  nsq = (nr << SHIFT) | nf;
 463   3                  piece = BoardState[nsq];
 464   3      
 465   3                  if ((piece & TYPE_MASK) == TYPE_EMPTY)
 466   3                      continue;
 467   3      
 468   3                  if (((piece & COLOR_WHITE) != 0) == attacker_color) {
 469   4                      type = piece & TYPE_MASK;
 470   4                      if (type == TYPE_BISHOP || type == TYPE_QUEEN)
 471   4                          return 1;
 472   4                  }
 473   3                  break;
 474   3              }
 475   2          }
 476   1      
 477   1          /* ---------- King attacks (adjacent squares) ---------- */
 478   1          for (i = 0; i < 8; i++) {
 479   2              nr = r + dr[i];
 480   2              nf = f + df[i];
 481   2      
 482   2              if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/30/2026 14:01:07 PAGE 9   

 483   2                  continue;
 484   2      
 485   2              nsq = (nr << SHIFT) | nf;
 486   2              piece = BoardState[nsq];
 487   2      
 488   2              if ((piece & TYPE_MASK) == TYPE_KING && ((piece & COLOR_WHITE) != 0) == attacker_color) return 1;
 489   2          }
 490   1      
 491   1          return 0;
 492   1      }
 493          
 494          bit is_game_over(void)
 495          {
 496   1          U8 sq, r;
 497   1          Bitboard moves;
 498   1      
 499   1          // 1) King first
 500   1          get_legal_moves(KingSquares[TURN], &moves, 1);
 501   1          for (r = 0; r < BOARD_W; r++) if (moves.RANK[r]) return 0;
 502   1      
 503   1          // 2) All other pieces
 504   1          for (sq = 0; sq < BOARD_W*BOARD_W; sq++) {
 505   2              if (BoardState[sq] == EMPTY) continue;
 506   2              if (((BoardState[sq] & COLOR_WHITE) != 0) != TURN) continue;
 507   2              if ((BoardState[sq] & TYPE_MASK) == TYPE_KING) continue;
 508   2      
 509   2              get_legal_moves(sq, &moves, 1);
 510   2              for (r = 0; r < BOARD_W; r++) if (moves.RANK[r]) return 0;
 511   2          }
 512   1          
 513   1          GAME_OVER_INFO = 0;
 514   1          if (is_square_attacked(KingSquares[TURN], !TURN)) GAME_OVER_INFO = 1;
 515   1      
 516   1          return 1;
 517   1      }
 518          
 519          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2785    ----
   CONSTANT SIZE    =     48    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      78
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       6
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
