C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MOVE_GEN
OBJECT MODULE PLACED IN .\Objects\move_gen.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE src\move_gen.c OPTIMIZE(9,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listi
                    -ngs\move_gen.lst) TABS(2) OBJECT(.\Objects\move_gen.obj)

line level    source

   1          #include "move_gen.h"
   2          
   3          #include "types.h"
   4          #include "bitboard.h"
   5          
   6          // King directions
   7          static const signed char code dr[8] = {-1,-1,-1,0,0,1,1,1};
   8          static const signed char code df[8] = {-1,0,1,-1,1,-1,0,1};
   9          
  10          // Rook directions
  11          static const signed char code dr_rook[4] = { -1,  1,  0,  0 };
  12          static const signed char code df_rook[4] = {  0,  0, -1,  1 };
  13          
  14          // Bishop directions
  15          static const signed char code dr_bishop[4] = { -1, -1,  1,  1 };
  16          static const signed char code df_bishop[4] = { -1,  1, -1,  1 };
  17          
  18          // Knight directions
  19          static const signed char code dr_knight[8] = { -2, -2, -1, -1,  1,  1,  2,  2 };
  20          static const signed char code df_knight[8] = { -1,  1, -2,  2, -2,  2, -1,  1 };
  21          
  22          // Pawn directions
  23          static const U8 code pawn_forward[2][4] = {
  24              {0x02, 0x04, 0x08, 0x10},  // White
  25              {0x10, 0x08, 0x04, 0x02}   // Black
  26          };
  27          
  28          
  29          U8 GAME_OVER_INFO = 0;
  30          
  31              
  32          void get_legal_moves(U8 sq, Bitboard *legal_board, bit pass) {
  33   1      
  34   1          U8 r, f, to_sq;
  35   1          bit piece_turn;
  36   1          U8 from_piece, captured_piece;
  37   1          U8 old_king_sq;
  38   1      
  39   1          Bitboard pseudo_board;
  40   1      
  41   1          pseudo_board.RANK[0] = 0;
  42   1          pseudo_board.RANK[1] = 0;
  43   1          pseudo_board.RANK[2] = 0;
  44   1          pseudo_board.RANK[3] = 0;
  45   1      
  46   1          *legal_board  = ZeroBoard;
  47   1      
  48   1          from_piece = BoardState[sq];
  49   1          old_king_sq = KingSquares[TURN];
  50   1        
  51   1          if ((from_piece & TYPE_MASK) == TYPE_EMPTY) return;
  52   1      
  53   1          piece_turn = (from_piece & COLOR_WHITE) != 0;
  54   1      
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 2   

  55   1          if (piece_turn != TURN) return;
  56   1          if (!pass) if (piece_turn != COLOR) return;
  57   1      
  58   1          /* --- Generate pseudo-legal moves --- */
  59   1          switch (from_piece & TYPE_MASK) {
  60   2              case TYPE_KNIGHT:
  61   2                  get_knight_moves(sq, &pseudo_board);
  62   2                  break;
  63   2              case TYPE_BISHOP:
  64   2                  get_bishop_moves(sq, &pseudo_board);
  65   2                  break;
  66   2              case TYPE_ROOK:
  67   2                  get_rook_moves(sq, &pseudo_board);
  68   2                  break;
  69   2              case TYPE_QUEEN:
  70   2                  get_bishop_moves(sq, &pseudo_board);
  71   2                  get_rook_moves(sq, &pseudo_board);
  72   2                  break;
  73   2              case TYPE_KING:
  74   2                  get_king_moves(sq, &pseudo_board);
  75   2                  break;
  76   2              default:
  77   2                  break;
  78   2          }
  79   1      
  80   1          /* --- Filter to legal moves --- */
  81   1          for (r = 0; r < BOARD_W; r++) {
  82   2              for (f = 0; f < BOARD_W; f++) {
  83   3      
  84   3                  if (!(pseudo_board.RANK[r] & (1 << f)))
  85   3                      continue;
  86   3      
  87   3                  to_sq = (r << SHIFT) | f;
  88   3      
  89   3                  /* make temporary move */
  90   3                  captured_piece = BoardState[to_sq];
  91   3                  BoardState[to_sq] = from_piece;
  92   3                  BoardState[sq] = TYPE_EMPTY;
  93   3      
  94   3                  if ((from_piece & TYPE_MASK) == TYPE_KING)
  95   3                      KingSquares[TURN] = to_sq;
  96   3      
  97   3                  /* check king safety */
  98   3                  if (!is_square_attacked(KingSquares[TURN], !TURN)) {
  99   4                      legal_board->RANK[r] |= (1 << f);
 100   4                  }
 101   3      
 102   3                  /* undo move */
 103   3                  BoardState[sq] = from_piece;
 104   3                  BoardState[to_sq] = captured_piece;
 105   3                  KingSquares[TURN] = old_king_sq;
 106   3              }
 107   2          }
 108   1      
 109   1      }
 110          
 111          
 112          void get_king_moves(U8 sq, Bitboard *board) {
 113   1        U8 i, piece, color, rank, file, new_sq, target;
 114   1        signed char r, f;
 115   1        
 116   1          piece = BoardState[sq];
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 3   

 117   1          color = piece & COLOR_WHITE;
 118   1          rank = sq >> 2;
 119   1          file = sq & MASK;
 120   1      
 121   1          // King direction offsets
 122   1      
 123   1      
 124   1          for (i=0; i<8; i++) {
 125   2              r = rank + dr[i];
 126   2              f = file + df[i];
 127   2      
 128   2              if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 129   2                  continue;
 130   2      
 131   2              new_sq = (r << SHIFT) + f;
 132   2              target = BoardState[new_sq];
 133   2      
 134   2              if ((target & TYPE_MASK) == TYPE_EMPTY || (target & COLOR_WHITE) != color) {
 135   3                  board->RANK[r] |= (1 << f);
 136   3              }
 137   2          }
 138   1      }
 139          
 140          void get_rook_moves(U8 sq, Bitboard *board) {
 141   1          U8 i, piece, color, target;
 142   1          signed char r, f;
 143   1          U8 rank, file;
 144   1      
 145   1          piece = BoardState[sq];
 146   1          color = piece & COLOR_WHITE;
 147   1          rank = sq >> 2;
 148   1          file = sq & MASK;
 149   1      
 150   1          for (i = 0; i < 4; i++) {
 151   2              r = rank;
 152   2              f = file;
 153   2      
 154   2              while (1) {
 155   3                  r += dr_rook[i];
 156   3                  f += df_rook[i];
 157   3      
 158   3                  if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 159   3                      break;
 160   3      
 161   3                  target = BoardState[(r << SHIFT) + f];
 162   3      
 163   3                  if ((target & TYPE_MASK) == TYPE_EMPTY) {
 164   4                      board->RANK[r] |= (1 << f);
 165   4                  } else {
 166   4                      if ((target & COLOR_WHITE) != color)
 167   4                          board->RANK[r] |= (1 << f);
 168   4                      break;   // blocked
 169   4                  }
 170   3              }
 171   2          }
 172   1      }
 173          
 174          void get_bishop_moves(U8 sq, Bitboard *board) {
 175   1          U8 i, piece, color, target;
 176   1          signed char r, f;
 177   1          U8 rank, file;
 178   1      
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 4   

 179   1          piece = BoardState[sq];
 180   1          color = piece & COLOR_WHITE;
 181   1          rank = sq >> 2;
 182   1          file = sq & MASK;
 183   1      
 184   1          for (i = 0; i < 4; i++) {
 185   2              r = rank;
 186   2              f = file;
 187   2      
 188   2              while (1) {
 189   3                  r += dr_bishop[i];
 190   3                  f += df_bishop[i];
 191   3      
 192   3                  if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 193   3                      break;
 194   3      
 195   3                  target = BoardState[(r << SHIFT) + f];
 196   3      
 197   3                  if ((target & TYPE_MASK) == TYPE_EMPTY) {
 198   4                      board->RANK[r] |= (1 << f);
 199   4                  } else {
 200   4                      if ((target & COLOR_WHITE) != color)
 201   4                          board->RANK[r] |= (1 << f);
 202   4                      break;   // blocked
 203   4                  }
 204   3              }
 205   2          }
 206   1      }
 207          
 208          void get_knight_moves(U8 sq, Bitboard *board) {
 209   1          U8 i, piece, color, target;
 210   1          signed char r, f;
 211   1          U8 rank, file;
 212   1      
 213   1          piece = BoardState[sq];
 214   1          color = piece & COLOR_WHITE;
 215   1          rank = sq >> 2;
 216   1          file = sq & MASK;
 217   1      
 218   1          for (i = 0; i < 8; i++) {
 219   2              r = rank + dr_knight[i];
 220   2              f = file + df_knight[i];
 221   2      
 222   2              if (r < 0 || r >= BOARD_W || f < 0 || f >= BOARD_W)
 223   2                  continue;
 224   2      
 225   2              target = BoardState[(r << SHIFT) + f];
 226   2      
 227   2              if ((target & TYPE_MASK) == TYPE_EMPTY || (target & COLOR_WHITE) != color) {
 228   3                  board->RANK[r] |= (1 << f);
 229   3              }
 230   2          }
 231   1      }
 232          
 233          bit is_square_attacked(U8 sq, bit attacker_color)
 234          {
 235   1          U8 r = sq >> 2;
 236   1          U8 f = sq & MASK;
 237   1          signed char nr, nf;
 238   1          U8 i, nsq, piece, type;
 239   1      
 240   1          /* ---------- Knight attacks ---------- */
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 5   

 241   1          for (i = 0; i < 8; i++) {
 242   2              nr = r + dr_knight[i];
 243   2              nf = f + df_knight[i];
 244   2      
 245   2              if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 246   2                  continue;
 247   2      
 248   2              nsq = (nr << SHIFT) | nf;
 249   2              piece = BoardState[nsq];
 250   2      
 251   2              if ((piece & TYPE_MASK) == TYPE_KNIGHT && ((piece & COLOR_WHITE) != 0) == attacker_color) return 1
             -;
 252   2          }
 253   1      
 254   1          /* ---------- Rook / Queen attacks ---------- */
 255   1          for (i = 0; i < 4; i++) {
 256   2              nr = r;
 257   2              nf = f;
 258   2      
 259   2              while (1) {
 260   3                  nr += dr_rook[i];
 261   3                  nf += df_rook[i];
 262   3      
 263   3                  if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 264   3                      break;
 265   3      
 266   3                  nsq = (nr << SHIFT) | nf;
 267   3                  piece = BoardState[nsq];
 268   3      
 269   3                  if ((piece & TYPE_MASK) == TYPE_EMPTY)
 270   3                      continue;
 271   3      
 272   3                  if (((piece & COLOR_WHITE) != 0) == attacker_color) {
 273   4                      type = piece & TYPE_MASK;
 274   4                      if (type == TYPE_ROOK || type == TYPE_QUEEN)
 275   4                          return 1;
 276   4                  }
 277   3                  break;  // blocked
 278   3              }
 279   2          }
 280   1      
 281   1          /* ---------- Bishop / Queen attacks ---------- */
 282   1          for (i = 0; i < 4; i++) {
 283   2              nr = r;
 284   2              nf = f;
 285   2      
 286   2              while (1) {
 287   3                  nr += dr_bishop[i];
 288   3                  nf += df_bishop[i];
 289   3      
 290   3                  if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 291   3                      break;
 292   3      
 293   3                  nsq = (nr << SHIFT) | nf;
 294   3                  piece = BoardState[nsq];
 295   3      
 296   3                  if ((piece & TYPE_MASK) == TYPE_EMPTY)
 297   3                      continue;
 298   3      
 299   3                  if (((piece & COLOR_WHITE) != 0) == attacker_color) {
 300   4                      type = piece & TYPE_MASK;
 301   4                      if (type == TYPE_BISHOP || type == TYPE_QUEEN)
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 6   

 302   4                          return 1;
 303   4                  }
 304   3                  break;
 305   3              }
 306   2          }
 307   1      
 308   1          /* ---------- King attacks (adjacent squares) ---------- */
 309   1          for (i = 0; i < 8; i++) {
 310   2              nr = r + dr[i];
 311   2              nf = f + df[i];
 312   2      
 313   2              if (nr < 0 || nr >= BOARD_W || nf < 0 || nf >= BOARD_W)
 314   2                  continue;
 315   2      
 316   2              nsq = (nr << SHIFT) | nf;
 317   2              piece = BoardState[nsq];
 318   2      
 319   2              if ((piece & TYPE_MASK) == TYPE_KING && ((piece & COLOR_WHITE) != 0) == attacker_color) return 1;
 320   2          }
 321   1      
 322   1          return 0;
 323   1      }
 324          
 325          bit is_game_over(void)
 326          {
 327   1          U8 sq;
 328   1          Bitboard moves;
 329   1      
 330   1          // 1) King first
 331   1          get_legal_moves(KingSquares[TURN], &moves, 1);
 332   1          if (moves.RANK[0] | moves.RANK[1] |
 333   1              moves.RANK[2] | moves.RANK[3])
 334   1              return 0;
 335   1      
 336   1          // 2) All other pieces
 337   1          for (sq = 0; sq < BOARD_W*BOARD_W; sq++) {
 338   2              if (BoardState[sq] == EMPTY) continue;
 339   2              if (((BoardState[sq] & COLOR_WHITE) != 0) != TURN) continue;
 340   2              if ((BoardState[sq] & TYPE_MASK) == TYPE_KING) continue;
 341   2      
 342   2              get_legal_moves(sq, &moves, 1);
 343   2              if (moves.RANK[0] | moves.RANK[1] |
 344   2                  moves.RANK[2] | moves.RANK[3])
 345   2                  return 0;
 346   2          }
 347   1          
 348   1          GAME_OVER_INFO = 0;
 349   1          if (is_square_attacked(KingSquares[TURN], !TURN)) GAME_OVER_INFO = 1;
 350   1      
 351   1          return 1;
 352   1      }
 353          
 354          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1460    ----
   CONSTANT SIZE    =     56    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1      50
   IDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MOVE_GEN                                                          01/19/2026 02:57:11 PAGE 7   

   BIT SIZE         =   ----       3
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
